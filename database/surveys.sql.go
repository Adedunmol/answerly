// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: surveys.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const completeSurvey = `-- name: CompleteSurvey :one
UPDATE user_survey_responses
SET
    status = 'completed',
    percentage_completed = 100.00,
    completed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND survey_id = $2
    RETURNING id, user_id, survey_id, status, percentage_completed, started_at, completed_at, updated_at
`

type CompleteSurveyParams struct {
	UserID   int64
	SurveyID int64
}

func (q *Queries) CompleteSurvey(ctx context.Context, arg CompleteSurveyParams) (UserSurveyResponse, error) {
	row := q.db.QueryRow(ctx, completeSurvey, arg.UserID, arg.SurveyID)
	var i UserSurveyResponse
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SurveyID,
		&i.Status,
		&i.PercentageCompleted,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countAnsweredQuestions = `-- name: CountAnsweredQuestions :one
SELECT COUNT(*) FROM answer_responses
WHERE user_survey_response_id = $1
`

func (q *Queries) CountAnsweredQuestions(ctx context.Context, userSurveyResponseID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countAnsweredQuestions, userSurveyResponseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuestion = `-- name: CreateQuestion :one

INSERT INTO survey_questions (
    survey_id,
    question_text,
    question_type,
    is_required,
    order_index
) VALUES (
             $1, $2, $3, $4, $5
         ) RETURNING id, survey_id, question_text, question_type, is_required, order_index, created_at
`

type CreateQuestionParams struct {
	SurveyID     int64
	QuestionText string
	QuestionType string
	IsRequired   pgtype.Bool
	OrderIndex   int32
}

// ==================== Question Management ====================
func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (SurveyQuestion, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.SurveyID,
		arg.QuestionText,
		arg.QuestionType,
		arg.IsRequired,
		arg.OrderIndex,
	)
	var i SurveyQuestion
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.QuestionText,
		&i.QuestionType,
		&i.IsRequired,
		&i.OrderIndex,
		&i.CreatedAt,
	)
	return i, err
}

const createQuestionOption = `-- name: CreateQuestionOption :one

INSERT INTO question_options (
    question_id,
    option_text,
    order_index
) VALUES (
             $1, $2, $3
         ) RETURNING id, question_id, option_text, order_index, created_at
`

type CreateQuestionOptionParams struct {
	QuestionID int64
	OptionText string
	OrderIndex int32
}

// ==================== Question Options Management ====================
func (q *Queries) CreateQuestionOption(ctx context.Context, arg CreateQuestionOptionParams) (QuestionOption, error) {
	row := q.db.QueryRow(ctx, createQuestionOption, arg.QuestionID, arg.OptionText, arg.OrderIndex)
	var i QuestionOption
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.OptionText,
		&i.OrderIndex,
		&i.CreatedAt,
	)
	return i, err
}

const createSurvey = `-- name: CreateSurvey :one
INSERT INTO surveys (
    title,
    description,
    category,
    estimated_time_minutes,
    reward,
    eligibility,
    created_by
) VALUES (
             $1, $2, $3, $4, $5, $6, $7
         ) RETURNING id, title, description, category, estimated_time_minutes, reward, eligibility, status, created_by, created_at, updated_at
`

type CreateSurveyParams struct {
	Title                string
	Description          pgtype.Text
	Category             string
	EstimatedTimeMinutes int32
	Reward               pgtype.Numeric
	Eligibility          pgtype.Text
	CreatedBy            int64
}

func (q *Queries) CreateSurvey(ctx context.Context, arg CreateSurveyParams) (Survey, error) {
	row := q.db.QueryRow(ctx, createSurvey,
		arg.Title,
		arg.Description,
		arg.Category,
		arg.EstimatedTimeMinutes,
		arg.Reward,
		arg.Eligibility,
		arg.CreatedBy,
	)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Category,
		&i.EstimatedTimeMinutes,
		&i.Reward,
		&i.Eligibility,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAnswer = `-- name: DeleteAnswer :exec
DELETE FROM answer_responses
WHERE id = $1
`

func (q *Queries) DeleteAnswer(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAnswer, id)
	return err
}

const deleteAnswersByUserSurveyResponse = `-- name: DeleteAnswersByUserSurveyResponse :exec
DELETE FROM answer_responses
WHERE user_survey_response_id = $1
`

func (q *Queries) DeleteAnswersByUserSurveyResponse(ctx context.Context, userSurveyResponseID int64) error {
	_, err := q.db.Exec(ctx, deleteAnswersByUserSurveyResponse, userSurveyResponseID)
	return err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM survey_questions
WHERE id = $1
`

func (q *Queries) DeleteQuestion(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteQuestion, id)
	return err
}

const deleteQuestionOption = `-- name: DeleteQuestionOption :exec
DELETE FROM question_options
WHERE id = $1
`

func (q *Queries) DeleteQuestionOption(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteQuestionOption, id)
	return err
}

const deleteSurvey = `-- name: DeleteSurvey :exec
DELETE FROM surveys
WHERE id = $1
`

func (q *Queries) DeleteSurvey(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSurvey, id)
	return err
}

const getAnswer = `-- name: GetAnswer :one
SELECT id, user_survey_response_id, question_id, answer_text, selected_option_ids, answered_at, updated_at FROM answer_responses
WHERE user_survey_response_id = $1 AND question_id = $2
`

type GetAnswerParams struct {
	UserSurveyResponseID int64
	QuestionID           int64
}

func (q *Queries) GetAnswer(ctx context.Context, arg GetAnswerParams) (AnswerResponse, error) {
	row := q.db.QueryRow(ctx, getAnswer, arg.UserSurveyResponseID, arg.QuestionID)
	var i AnswerResponse
	err := row.Scan(
		&i.ID,
		&i.UserSurveyResponseID,
		&i.QuestionID,
		&i.AnswerText,
		&i.SelectedOptionIds,
		&i.AnsweredAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAnswersByUserSurveyResponse = `-- name: GetAnswersByUserSurveyResponse :many
SELECT id, user_survey_response_id, question_id, answer_text, selected_option_ids, answered_at, updated_at FROM answer_responses
WHERE user_survey_response_id = $1
ORDER BY answered_at
`

func (q *Queries) GetAnswersByUserSurveyResponse(ctx context.Context, userSurveyResponseID int64) ([]AnswerResponse, error) {
	rows, err := q.db.Query(ctx, getAnswersByUserSurveyResponse, userSurveyResponseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnswerResponse
	for rows.Next() {
		var i AnswerResponse
		if err := rows.Scan(
			&i.ID,
			&i.UserSurveyResponseID,
			&i.QuestionID,
			&i.AnswerText,
			&i.SelectedOptionIds,
			&i.AnsweredAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnswersWithQuestions = `-- name: GetAnswersWithQuestions :many
SELECT
    ar.id, ar.user_survey_response_id, ar.question_id, ar.answer_text, ar.selected_option_ids, ar.answered_at, ar.updated_at,
    sq.question_text,
    sq.question_type,
    sq.order_index
FROM answer_responses ar
         INNER JOIN survey_questions sq ON ar.question_id = sq.id
WHERE ar.user_survey_response_id = $1
ORDER BY sq.order_index
`

type GetAnswersWithQuestionsRow struct {
	ID                   int64
	UserSurveyResponseID int64
	QuestionID           int64
	AnswerText           pgtype.Text
	SelectedOptionIds    []int64
	AnsweredAt           pgtype.Timestamp
	UpdatedAt            pgtype.Timestamp
	QuestionText         string
	QuestionType         string
	OrderIndex           int32
}

func (q *Queries) GetAnswersWithQuestions(ctx context.Context, userSurveyResponseID int64) ([]GetAnswersWithQuestionsRow, error) {
	rows, err := q.db.Query(ctx, getAnswersWithQuestions, userSurveyResponseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAnswersWithQuestionsRow
	for rows.Next() {
		var i GetAnswersWithQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserSurveyResponseID,
			&i.QuestionID,
			&i.AnswerText,
			&i.SelectedOptionIds,
			&i.AnsweredAt,
			&i.UpdatedAt,
			&i.QuestionText,
			&i.QuestionType,
			&i.OrderIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptionsByQuestionID = `-- name: GetOptionsByQuestionID :many
SELECT id, question_id, option_text, order_index, created_at FROM question_options
WHERE question_id = $1
ORDER BY order_index
`

func (q *Queries) GetOptionsByQuestionID(ctx context.Context, questionID int64) ([]QuestionOption, error) {
	rows, err := q.db.Query(ctx, getOptionsByQuestionID, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuestionOption
	for rows.Next() {
		var i QuestionOption
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.OptionText,
			&i.OrderIndex,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptionsByQuestionIDs = `-- name: GetOptionsByQuestionIDs :many
SELECT id, question_id, option_text, order_index, created_at FROM question_options
WHERE question_id = ANY($1::bigint[])
ORDER BY question_id, order_index
`

func (q *Queries) GetOptionsByQuestionIDs(ctx context.Context, dollar_1 []int64) ([]QuestionOption, error) {
	rows, err := q.db.Query(ctx, getOptionsByQuestionIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuestionOption
	for rows.Next() {
		var i QuestionOption
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.OptionText,
			&i.OrderIndex,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestion = `-- name: GetQuestion :one
SELECT id, survey_id, question_text, question_type, is_required, order_index, created_at FROM survey_questions
WHERE id = $1
`

func (q *Queries) GetQuestion(ctx context.Context, id int64) (SurveyQuestion, error) {
	row := q.db.QueryRow(ctx, getQuestion, id)
	var i SurveyQuestion
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.QuestionText,
		&i.QuestionType,
		&i.IsRequired,
		&i.OrderIndex,
		&i.CreatedAt,
	)
	return i, err
}

const getQuestionsBySurveyID = `-- name: GetQuestionsBySurveyID :many
SELECT id, survey_id, question_text, question_type, is_required, order_index, created_at FROM survey_questions
WHERE survey_id = $1
ORDER BY order_index
`

func (q *Queries) GetQuestionsBySurveyID(ctx context.Context, surveyID int64) ([]SurveyQuestion, error) {
	rows, err := q.db.Query(ctx, getQuestionsBySurveyID, surveyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SurveyQuestion
	for rows.Next() {
		var i SurveyQuestion
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.QuestionText,
			&i.QuestionType,
			&i.IsRequired,
			&i.OrderIndex,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSurvey = `-- name: GetSurvey :one
SELECT id, title, description, category, estimated_time_minutes, reward, eligibility, status, created_by, created_at, updated_at FROM surveys
WHERE id = $1
`

func (q *Queries) GetSurvey(ctx context.Context, id int64) (Survey, error) {
	row := q.db.QueryRow(ctx, getSurvey, id)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Category,
		&i.EstimatedTimeMinutes,
		&i.Reward,
		&i.Eligibility,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSurveyDetailWithQuestionsAndOptions = `-- name: GetSurveyDetailWithQuestionsAndOptions :many

SELECT
    s.id as survey_id,
    s.title as survey_title,
    s.description as survey_description,
    s.category as survey_category,
    s.estimated_time_minutes,
    s.reward,
    s.eligibility,
    s.status as survey_status,
    s.created_by,
    s.created_at as survey_created_at,
    sq.id as question_id,
    sq.question_text,
    sq.question_type,
    sq.is_required,
    sq.order_index as question_order,
    qo.id as option_id,
    qo.option_text,
    qo.order_index as option_order
FROM surveys s
         LEFT JOIN survey_questions sq ON s.id = sq.survey_id
         LEFT JOIN question_options qo ON sq.id = qo.question_id
WHERE s.id = $1
ORDER BY sq.order_index, qo.order_index
`

type GetSurveyDetailWithQuestionsAndOptionsRow struct {
	SurveyID             int64
	SurveyTitle          string
	SurveyDescription    pgtype.Text
	SurveyCategory       string
	EstimatedTimeMinutes int32
	Reward               pgtype.Numeric
	Eligibility          pgtype.Text
	SurveyStatus         pgtype.Text
	CreatedBy            int64
	SurveyCreatedAt      pgtype.Timestamp
	QuestionID           pgtype.Int8
	QuestionText         pgtype.Text
	QuestionType         pgtype.Text
	IsRequired           pgtype.Bool
	QuestionOrder        pgtype.Int4
	OptionID             pgtype.Int8
	OptionText           pgtype.Text
	OptionOrder          pgtype.Int4
}

// ==================== Complex Queries for Survey Details ====================
func (q *Queries) GetSurveyDetailWithQuestionsAndOptions(ctx context.Context, id int64) ([]GetSurveyDetailWithQuestionsAndOptionsRow, error) {
	rows, err := q.db.Query(ctx, getSurveyDetailWithQuestionsAndOptions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSurveyDetailWithQuestionsAndOptionsRow
	for rows.Next() {
		var i GetSurveyDetailWithQuestionsAndOptionsRow
		if err := rows.Scan(
			&i.SurveyID,
			&i.SurveyTitle,
			&i.SurveyDescription,
			&i.SurveyCategory,
			&i.EstimatedTimeMinutes,
			&i.Reward,
			&i.Eligibility,
			&i.SurveyStatus,
			&i.CreatedBy,
			&i.SurveyCreatedAt,
			&i.QuestionID,
			&i.QuestionText,
			&i.QuestionType,
			&i.IsRequired,
			&i.QuestionOrder,
			&i.OptionID,
			&i.OptionText,
			&i.OptionOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSurveyStats = `-- name: GetSurveyStats :one

SELECT
    s.id,
    s.title,
    COUNT(DISTINCT usr.user_id) as total_participants,
    COUNT(DISTINCT CASE WHEN usr.status = 'completed' THEN usr.user_id END) as completed_count,
    COUNT(DISTINCT CASE WHEN usr.status = 'in_progress' THEN usr.user_id END) as in_progress_count,
    AVG(usr.percentage_completed) as avg_completion_percentage
FROM surveys s
         LEFT JOIN user_survey_responses usr ON s.id = usr.survey_id
WHERE s.id = $1
GROUP BY s.id
`

type GetSurveyStatsRow struct {
	ID                      int64
	Title                   string
	TotalParticipants       int64
	CompletedCount          int64
	InProgressCount         int64
	AvgCompletionPercentage float64
}

// ==================== Analytics/Stats Queries ====================
func (q *Queries) GetSurveyStats(ctx context.Context, id int64) (GetSurveyStatsRow, error) {
	row := q.db.QueryRow(ctx, getSurveyStats, id)
	var i GetSurveyStatsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TotalParticipants,
		&i.CompletedCount,
		&i.InProgressCount,
		&i.AvgCompletionPercentage,
	)
	return i, err
}

const getSurveyWithQuestions = `-- name: GetSurveyWithQuestions :many
SELECT
    s.id, s.title, s.description, s.category, s.estimated_time_minutes, s.reward, s.eligibility, s.status, s.created_by, s.created_at, s.updated_at,
    sq.id as question_id,
    sq.question_text,
    sq.question_type,
    sq.is_required,
    sq.order_index as question_order
FROM surveys s
         LEFT JOIN survey_questions sq ON s.id = sq.survey_id
WHERE s.id = $1
ORDER BY sq.order_index
`

type GetSurveyWithQuestionsRow struct {
	ID                   int64
	Title                string
	Description          pgtype.Text
	Category             string
	EstimatedTimeMinutes int32
	Reward               pgtype.Numeric
	Eligibility          pgtype.Text
	Status               pgtype.Text
	CreatedBy            int64
	CreatedAt            pgtype.Timestamp
	UpdatedAt            pgtype.Timestamp
	QuestionID           pgtype.Int8
	QuestionText         pgtype.Text
	QuestionType         pgtype.Text
	IsRequired           pgtype.Bool
	QuestionOrder        pgtype.Int4
}

func (q *Queries) GetSurveyWithQuestions(ctx context.Context, id int64) ([]GetSurveyWithQuestionsRow, error) {
	rows, err := q.db.Query(ctx, getSurveyWithQuestions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSurveyWithQuestionsRow
	for rows.Next() {
		var i GetSurveyWithQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Category,
			&i.EstimatedTimeMinutes,
			&i.Reward,
			&i.Eligibility,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuestionID,
			&i.QuestionText,
			&i.QuestionType,
			&i.IsRequired,
			&i.QuestionOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCompletedSurveysCount = `-- name: GetUserCompletedSurveysCount :one
SELECT COUNT(*) FROM user_survey_responses
WHERE user_id = $1 AND status = 'completed'
`

func (q *Queries) GetUserCompletedSurveysCount(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserCompletedSurveysCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserSurveyProgress = `-- name: GetUserSurveyProgress :one
SELECT
    usr.id, usr.user_id, usr.survey_id, usr.status, usr.percentage_completed, usr.started_at, usr.completed_at, usr.updated_at,
    COUNT(DISTINCT sq.id) as total_questions,
    COUNT(DISTINCT ar.question_id) as answered_questions,
    CASE
        WHEN COUNT(DISTINCT sq.id) > 0
            THEN ROUND((COUNT(DISTINCT ar.question_id)::DECIMAL / COUNT(DISTINCT sq.id)::DECIMAL) * 100, 2)
        ELSE 0.00
        END as calculated_percentage
FROM user_survey_responses usr
         INNER JOIN surveys s ON usr.survey_id = s.id
         LEFT JOIN survey_questions sq ON s.id = sq.survey_id
         LEFT JOIN answer_responses ar ON usr.id = ar.user_survey_response_id AND sq.id = ar.question_id
WHERE usr.user_id = $1 AND usr.survey_id = $2
GROUP BY usr.id
`

type GetUserSurveyProgressParams struct {
	UserID   int64
	SurveyID int64
}

type GetUserSurveyProgressRow struct {
	ID                   int64
	UserID               int64
	SurveyID             int64
	Status               pgtype.Text
	PercentageCompleted  pgtype.Numeric
	StartedAt            pgtype.Timestamp
	CompletedAt          pgtype.Timestamp
	UpdatedAt            pgtype.Timestamp
	TotalQuestions       int64
	AnsweredQuestions    int64
	CalculatedPercentage float64
}

func (q *Queries) GetUserSurveyProgress(ctx context.Context, arg GetUserSurveyProgressParams) (GetUserSurveyProgressRow, error) {
	row := q.db.QueryRow(ctx, getUserSurveyProgress, arg.UserID, arg.SurveyID)
	var i GetUserSurveyProgressRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SurveyID,
		&i.Status,
		&i.PercentageCompleted,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UpdatedAt,
		&i.TotalQuestions,
		&i.AnsweredQuestions,
		&i.CalculatedPercentage,
	)
	return i, err
}

const getUserSurveyResponse = `-- name: GetUserSurveyResponse :one
SELECT id, user_id, survey_id, status, percentage_completed, started_at, completed_at, updated_at FROM user_survey_responses
WHERE user_id = $1 AND survey_id = $2
`

type GetUserSurveyResponseParams struct {
	UserID   int64
	SurveyID int64
}

func (q *Queries) GetUserSurveyResponse(ctx context.Context, arg GetUserSurveyResponseParams) (UserSurveyResponse, error) {
	row := q.db.QueryRow(ctx, getUserSurveyResponse, arg.UserID, arg.SurveyID)
	var i UserSurveyResponse
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SurveyID,
		&i.Status,
		&i.PercentageCompleted,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserSurveyResponseByID = `-- name: GetUserSurveyResponseByID :one
SELECT id, user_id, survey_id, status, percentage_completed, started_at, completed_at, updated_at FROM user_survey_responses
WHERE id = $1
`

func (q *Queries) GetUserSurveyResponseByID(ctx context.Context, id int64) (UserSurveyResponse, error) {
	row := q.db.QueryRow(ctx, getUserSurveyResponseByID, id)
	var i UserSurveyResponse
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SurveyID,
		&i.Status,
		&i.PercentageCompleted,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserSurveyWithAnswers = `-- name: GetUserSurveyWithAnswers :many
SELECT
    usr.id, usr.user_id, usr.survey_id, usr.status, usr.percentage_completed, usr.started_at, usr.completed_at, usr.updated_at,
    s.title as survey_title,
    s.category,
    s.estimated_time_minutes,
    s.reward,
    ar.id as answer_id,
    ar.question_id,
    ar.answer_text,
    ar.selected_option_ids,
    sq.question_text,
    sq.question_type
FROM user_survey_responses usr
         INNER JOIN surveys s ON usr.survey_id = s.id
         LEFT JOIN answer_responses ar ON usr.id = ar.user_survey_response_id
         LEFT JOIN survey_questions sq ON ar.question_id = sq.id
WHERE usr.user_id = $1 AND usr.survey_id = $2
ORDER BY sq.order_index
`

type GetUserSurveyWithAnswersParams struct {
	UserID   int64
	SurveyID int64
}

type GetUserSurveyWithAnswersRow struct {
	ID                   int64
	UserID               int64
	SurveyID             int64
	Status               pgtype.Text
	PercentageCompleted  pgtype.Numeric
	StartedAt            pgtype.Timestamp
	CompletedAt          pgtype.Timestamp
	UpdatedAt            pgtype.Timestamp
	SurveyTitle          string
	Category             string
	EstimatedTimeMinutes int32
	Reward               pgtype.Numeric
	AnswerID             pgtype.Int8
	QuestionID           pgtype.Int8
	AnswerText           pgtype.Text
	SelectedOptionIds    []int64
	QuestionText         pgtype.Text
	QuestionType         pgtype.Text
}

func (q *Queries) GetUserSurveyWithAnswers(ctx context.Context, arg GetUserSurveyWithAnswersParams) ([]GetUserSurveyWithAnswersRow, error) {
	rows, err := q.db.Query(ctx, getUserSurveyWithAnswers, arg.UserID, arg.SurveyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSurveyWithAnswersRow
	for rows.Next() {
		var i GetUserSurveyWithAnswersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SurveyID,
			&i.Status,
			&i.PercentageCompleted,
			&i.StartedAt,
			&i.CompletedAt,
			&i.UpdatedAt,
			&i.SurveyTitle,
			&i.Category,
			&i.EstimatedTimeMinutes,
			&i.Reward,
			&i.AnswerID,
			&i.QuestionID,
			&i.AnswerText,
			&i.SelectedOptionIds,
			&i.QuestionText,
			&i.QuestionType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTotalRewards = `-- name: GetUserTotalRewards :one
SELECT COALESCE(SUM(s.reward), 0) as total_rewards
FROM user_survey_responses usr
         INNER JOIN surveys s ON usr.survey_id = s.id
WHERE usr.user_id = $1 AND usr.status = 'completed'
`

func (q *Queries) GetUserTotalRewards(ctx context.Context, userID int64) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserTotalRewards, userID)
	var total_rewards interface{}
	err := row.Scan(&total_rewards)
	return total_rewards, err
}

const listSurveys = `-- name: ListSurveys :many
SELECT id, title, description, category, estimated_time_minutes, reward, eligibility, status, created_by, created_at, updated_at FROM surveys
WHERE
    ($3::VARCHAR IS NULL OR category = $3)
  AND ($4::VARCHAR IS NULL OR status = $4)
ORDER BY created_at DESC
    LIMIT $1 OFFSET $2
`

type ListSurveysParams struct {
	Limit    int32
	Offset   int32
	Category pgtype.Text
	Status   pgtype.Text
}

func (q *Queries) ListSurveys(ctx context.Context, arg ListSurveysParams) ([]Survey, error) {
	rows, err := q.db.Query(ctx, listSurveys,
		arg.Limit,
		arg.Offset,
		arg.Category,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Survey
	for rows.Next() {
		var i Survey
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Category,
			&i.EstimatedTimeMinutes,
			&i.Reward,
			&i.Eligibility,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSurveys = `-- name: ListUserSurveys :many
SELECT
    s.id, s.title, s.description, s.category, s.estimated_time_minutes, s.reward, s.eligibility, s.status, s.created_by, s.created_at, s.updated_at,
    usr.id as user_survey_response_id,
    usr.status as response_status,
    usr.percentage_completed,
    usr.started_at,
    usr.completed_at,
    usr.updated_at as response_updated_at
FROM user_survey_responses usr
         INNER JOIN surveys s ON usr.survey_id = s.id
WHERE usr.user_id = $1
  AND ($2::VARCHAR IS NULL OR usr.status = $2)
ORDER BY usr.updated_at DESC
`

type ListUserSurveysParams struct {
	UserID int64
	Status pgtype.Text
}

type ListUserSurveysRow struct {
	ID                   int64
	Title                string
	Description          pgtype.Text
	Category             string
	EstimatedTimeMinutes int32
	Reward               pgtype.Numeric
	Eligibility          pgtype.Text
	Status               pgtype.Text
	CreatedBy            int64
	CreatedAt            pgtype.Timestamp
	UpdatedAt            pgtype.Timestamp
	UserSurveyResponseID int64
	ResponseStatus       pgtype.Text
	PercentageCompleted  pgtype.Numeric
	StartedAt            pgtype.Timestamp
	CompletedAt          pgtype.Timestamp
	ResponseUpdatedAt    pgtype.Timestamp
}

func (q *Queries) ListUserSurveys(ctx context.Context, arg ListUserSurveysParams) ([]ListUserSurveysRow, error) {
	rows, err := q.db.Query(ctx, listUserSurveys, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserSurveysRow
	for rows.Next() {
		var i ListUserSurveysRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Category,
			&i.EstimatedTimeMinutes,
			&i.Reward,
			&i.Eligibility,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserSurveyResponseID,
			&i.ResponseStatus,
			&i.PercentageCompleted,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ResponseUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveAnswer = `-- name: SaveAnswer :one

INSERT INTO answer_responses (
    user_survey_response_id,
    question_id,
    answer_text,
    selected_option_ids
) VALUES (
             $1, $2, $3, $4
         )
    ON CONFLICT (user_survey_response_id, question_id)
DO UPDATE SET
    answer_text = EXCLUDED.answer_text,
           selected_option_ids = EXCLUDED.selected_option_ids,
           updated_at = CURRENT_TIMESTAMP
           RETURNING id, user_survey_response_id, question_id, answer_text, selected_option_ids, answered_at, updated_at
`

type SaveAnswerParams struct {
	UserSurveyResponseID int64
	QuestionID           int64
	AnswerText           pgtype.Text
	SelectedOptionIds    []int64
}

// ==================== Answer Management ====================
func (q *Queries) SaveAnswer(ctx context.Context, arg SaveAnswerParams) (AnswerResponse, error) {
	row := q.db.QueryRow(ctx, saveAnswer,
		arg.UserSurveyResponseID,
		arg.QuestionID,
		arg.AnswerText,
		arg.SelectedOptionIds,
	)
	var i AnswerResponse
	err := row.Scan(
		&i.ID,
		&i.UserSurveyResponseID,
		&i.QuestionID,
		&i.AnswerText,
		&i.SelectedOptionIds,
		&i.AnsweredAt,
		&i.UpdatedAt,
	)
	return i, err
}

const startSurvey = `-- name: StartSurvey :one

INSERT INTO user_survey_responses (
    user_id,
    survey_id,
    status,
    percentage_completed
) VALUES (
             $1, $2, 'in_progress', 0.00
         ) RETURNING id, user_id, survey_id, status, percentage_completed, started_at, completed_at, updated_at
`

type StartSurveyParams struct {
	UserID   int64
	SurveyID int64
}

// ==================== User Survey Response Management ====================
func (q *Queries) StartSurvey(ctx context.Context, arg StartSurveyParams) (UserSurveyResponse, error) {
	row := q.db.QueryRow(ctx, startSurvey, arg.UserID, arg.SurveyID)
	var i UserSurveyResponse
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SurveyID,
		&i.Status,
		&i.PercentageCompleted,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAnswer = `-- name: UpdateAnswer :one
UPDATE answer_responses
SET
    answer_text = COALESCE($2, answer_text),
    selected_option_ids = COALESCE($3, selected_option_ids),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
    RETURNING id, user_survey_response_id, question_id, answer_text, selected_option_ids, answered_at, updated_at
`

type UpdateAnswerParams struct {
	ID                int64
	AnswerText        pgtype.Text
	SelectedOptionIds []int64
}

func (q *Queries) UpdateAnswer(ctx context.Context, arg UpdateAnswerParams) (AnswerResponse, error) {
	row := q.db.QueryRow(ctx, updateAnswer, arg.ID, arg.AnswerText, arg.SelectedOptionIds)
	var i AnswerResponse
	err := row.Scan(
		&i.ID,
		&i.UserSurveyResponseID,
		&i.QuestionID,
		&i.AnswerText,
		&i.SelectedOptionIds,
		&i.AnsweredAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE survey_questions
SET
    question_text = COALESCE($2, question_text),
    question_type = COALESCE($3, question_type),
    is_required = COALESCE($4, is_required),
    order_index = COALESCE($5, order_index)
WHERE id = $1
    RETURNING id, survey_id, question_text, question_type, is_required, order_index, created_at
`

type UpdateQuestionParams struct {
	ID           int64
	QuestionText pgtype.Text
	QuestionType pgtype.Text
	IsRequired   pgtype.Bool
	OrderIndex   pgtype.Int4
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (SurveyQuestion, error) {
	row := q.db.QueryRow(ctx, updateQuestion,
		arg.ID,
		arg.QuestionText,
		arg.QuestionType,
		arg.IsRequired,
		arg.OrderIndex,
	)
	var i SurveyQuestion
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.QuestionText,
		&i.QuestionType,
		&i.IsRequired,
		&i.OrderIndex,
		&i.CreatedAt,
	)
	return i, err
}

const updateQuestionOption = `-- name: UpdateQuestionOption :one
UPDATE question_options
SET
    option_text = COALESCE($2, option_text),
    order_index = COALESCE($3, order_index)
WHERE id = $1
    RETURNING id, question_id, option_text, order_index, created_at
`

type UpdateQuestionOptionParams struct {
	ID         int64
	OptionText pgtype.Text
	OrderIndex pgtype.Int4
}

func (q *Queries) UpdateQuestionOption(ctx context.Context, arg UpdateQuestionOptionParams) (QuestionOption, error) {
	row := q.db.QueryRow(ctx, updateQuestionOption, arg.ID, arg.OptionText, arg.OrderIndex)
	var i QuestionOption
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.OptionText,
		&i.OrderIndex,
		&i.CreatedAt,
	)
	return i, err
}

const updateSurvey = `-- name: UpdateSurvey :one
UPDATE surveys
SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    category = COALESCE($4, category),
    estimated_time_minutes = COALESCE($5, estimated_time_minutes),
    reward = COALESCE($6, reward),
    eligibility = COALESCE($7, eligibility),
    status = COALESCE($8, status),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
    RETURNING id, title, description, category, estimated_time_minutes, reward, eligibility, status, created_by, created_at, updated_at
`

type UpdateSurveyParams struct {
	ID                   int64
	Title                pgtype.Text
	Description          pgtype.Text
	Category             pgtype.Text
	EstimatedTimeMinutes pgtype.Int4
	Reward               pgtype.Numeric
	Eligibility          pgtype.Text
	Status               pgtype.Text
}

func (q *Queries) UpdateSurvey(ctx context.Context, arg UpdateSurveyParams) (Survey, error) {
	row := q.db.QueryRow(ctx, updateSurvey,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Category,
		arg.EstimatedTimeMinutes,
		arg.Reward,
		arg.Eligibility,
		arg.Status,
	)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Category,
		&i.EstimatedTimeMinutes,
		&i.Reward,
		&i.Eligibility,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSurveyProgress = `-- name: UpdateSurveyProgress :one
UPDATE user_survey_responses
SET
    percentage_completed = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
    RETURNING id, user_id, survey_id, status, percentage_completed, started_at, completed_at, updated_at
`

type UpdateSurveyProgressParams struct {
	ID                  int64
	PercentageCompleted pgtype.Numeric
}

func (q *Queries) UpdateSurveyProgress(ctx context.Context, arg UpdateSurveyProgressParams) (UserSurveyResponse, error) {
	row := q.db.QueryRow(ctx, updateSurveyProgress, arg.ID, arg.PercentageCompleted)
	var i UserSurveyResponse
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SurveyID,
		&i.Status,
		&i.PercentageCompleted,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserSurveyResponseStatus = `-- name: UpdateUserSurveyResponseStatus :one
UPDATE user_survey_responses
SET
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
    RETURNING id, user_id, survey_id, status, percentage_completed, started_at, completed_at, updated_at
`

type UpdateUserSurveyResponseStatusParams struct {
	ID     int64
	Status pgtype.Text
}

func (q *Queries) UpdateUserSurveyResponseStatus(ctx context.Context, arg UpdateUserSurveyResponseStatusParams) (UserSurveyResponse, error) {
	row := q.db.QueryRow(ctx, updateUserSurveyResponseStatus, arg.ID, arg.Status)
	var i UserSurveyResponse
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SurveyID,
		&i.Status,
		&i.PercentageCompleted,
		&i.StartedAt,
		&i.CompletedAt,
		&i.UpdatedAt,
	)
	return i, err
}
